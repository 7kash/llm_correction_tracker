<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM Learning Visualizer - See How AI Adapts & Changes Its Mind</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-matrix@2.0.1"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap');

        body {
            font-family: 'Inter', sans-serif;
        }

        .gradient-bg {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .gradient-bg-green {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        }

        .gradient-bg-blue {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .gradient-bg-orange {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        }

        .card-hover {
            transition: all 0.3s ease;
        }

        .card-hover:hover {
            transform: translateY(-4px);
            box-shadow: 0 20px 40px rgba(0,0,0,0.15);
        }

        .theory-box {
            background: linear-gradient(135deg, #e0f7fa 0%, #b2ebf2 100%);
            border-left: 5px solid #00acc1;
        }

        .explanation-box {
            background: linear-gradient(135deg, #f3e5f5 0%, #e1bee7 100%);
            border-left: 5px solid #9c27b0;
        }

        .calculation-box {
            background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%);
            border-left: 5px solid #ff9800;
        }

        .response-box {
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .pulse-dot {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .semantic-badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .badge-major { background: #fee; color: #c00; }
        .badge-big { background: #ffe; color: #c60; }
        .badge-moderate { background: #ffc; color: #960; }
        .badge-small { background: #efe; color: #060; }
        .badge-tiny { background: #eef; color: #006; }

        .chart-container {
            position: relative;
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.07);
        }

        .collapsible-section {
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 1rem;
            transition: all 0.3s ease;
        }

        .collapsible-section:hover {
            border-color: #9c27b0;
        }

        .section-header {
            cursor: pointer;
            user-select: none;
            transition: background 0.2s ease;
        }

        .section-header:hover {
            background: #f5f5f5;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-gray-50 to-gray-100 min-h-screen">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // API configuration
        const API_URL = 'http://localhost:5001/api';

        // Collapsible Section Component
        function CollapsibleSection({ title, icon, children, defaultOpen = false, colorClass = "bg-purple-50" }) {
            const [isOpen, setIsOpen] = useState(defaultOpen);

            return (
                <div className="collapsible-section">
                    <div
                        className={`section-header p-4 ${colorClass} flex items-center justify-between`}
                        onClick={() => setIsOpen(!isOpen)}
                    >
                        <div className="flex items-center gap-3">
                            <span className="text-2xl">{icon}</span>
                            <h3 className="text-lg font-semibold text-gray-800">{title}</h3>
                        </div>
                        <span className="text-2xl text-gray-600 transition-transform duration-200" style={{
                            transform: isOpen ? 'rotate(180deg)' : 'rotate(0deg)'
                        }}>
                            ▼
                        </span>
                    </div>
                    {isOpen && (
                        <div className="p-6 bg-white">
                            {children}
                        </div>
                    )}
                </div>
            );
        }

        // Theory Box Component
        function TheoryBox({ title, children }) {
            return (
                <div className="theory-box p-6 rounded-lg mb-6">
                    <h4 className="text-lg font-bold text-cyan-900 mb-3 flex items-center gap-2">
                        📚 {title}
                    </h4>
                    <div className="text-cyan-900 leading-relaxed space-y-2">
                        {children}
                    </div>
                </div>
            );
        }

        // Explanation Box Component
        function ExplanationBox({ title, children }) {
            return (
                <div className="explanation-box p-5 rounded-lg mb-4">
                    <h4 className="text-md font-bold text-purple-900 mb-2 flex items-center gap-2">
                        💡 {title}
                    </h4>
                    <div className="text-purple-900 text-sm leading-relaxed">
                        {children}
                    </div>
                </div>
            );
        }

        // Calculation Box Component
        function CalculationBox({ title, children }) {
            return (
                <div className="calculation-box p-5 rounded-lg mb-4">
                    <h4 className="text-md font-bold text-orange-900 mb-2 flex items-center gap-2">
                        🔢 {title}
                    </h4>
                    <div className="text-orange-900 text-sm leading-relaxed font-mono">
                        {children}
                    </div>
                </div>
            );
        }

        function App() {
            const [sessionId, setSessionId] = useState(null);
            const [question, setQuestion] = useState('');
            const [responses, setResponses] = useState([]);
            const [currentCorrection, setCurrentCorrection] = useState('');
            const [loading, setLoading] = useState(false);
            const [analytics, setAnalytics] = useState(null);
            const [semanticData, setSemanticData] = useState(null);
            const [loadingSemantic, setLoadingSemantic] = useState(false);

            const chartRefs = {
                wordCount: useRef(null),
                sentiment: useRef(null),
                confidence: useRef(null),
                similarityHeatmap: useRef(null),
                vectorMovement: useRef(null),
                sentenceComparison: useRef(null)
            };
            const chartInstances = useRef({});

            // Load semantic analysis when we have multiple responses
            useEffect(() => {
                if (sessionId && responses.length >= 2) {
                    loadSemanticAnalysis();
                }
            }, [sessionId, responses.length]);

            const loadSemanticAnalysis = async () => {
                setLoadingSemantic(true);
                try {
                    const response = await fetch(`${API_URL}/semantic-analysis/${sessionId}`);
                    if (response.ok) {
                        const data = await response.json();
                        setSemanticData(data);

                        // Update visualizations
                        setTimeout(() => {
                            if (data.similarity_matrix) {
                                updateSimilarityHeatmap(data.similarity_matrix);
                            }
                            if (data.projection_2d) {
                                updateVectorMovement(data.projection_2d);
                            }
                            if (data.sentence_comparison) {
                                updateSentenceComparison(data.sentence_comparison);
                            }
                        }, 100);
                    }
                } catch (error) {
                    console.error('Semantic analysis error:', error);
                } finally {
                    setLoadingSemantic(false);
                }
            };

            const startSession = async () => {
                if (!question.trim()) return;

                setLoading(true);
                try {
                    const response = await fetch(`${API_URL}/start-session`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ question })
                    });
                    const data = await response.json();

                    setSessionId(data.session_id);
                    setResponses([{
                        turn: data.turn,
                        type: 'initial',
                        response: data.response,
                        analysis: data.analysis
                    }]);

                    // Fetch full session data for analytics
                    fetchSessionData(data.session_id);
                } catch (error) {
                    alert('Error: ' + error.message);
                }
                setLoading(false);
            };

            const submitCorrection = async () => {
                if (!currentCorrection.trim() || !sessionId) return;

                setLoading(true);
                try {
                    const response = await fetch(`${API_URL}/correct`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            session_id: sessionId,
                            correction: currentCorrection
                        })
                    });
                    const data = await response.json();

                    setResponses(prev => [...prev, {
                        turn: data.turn,
                        type: 'correction',
                        response: data.response,
                        analysis: data.analysis
                    }]);
                    setCurrentCorrection('');

                    // Fetch updated session data
                    fetchSessionData(sessionId);
                } catch (error) {
                    alert('Error: ' + error.message);
                }
                setLoading(false);
            };

            const fetchSessionData = async (sid) => {
                try {
                    const response = await fetch(`${API_URL}/session/${sid}`);
                    const data = await response.json();
                    setAnalytics(data.analytics);

                    // Update charts
                    setTimeout(() => {
                        updateCharts(data.analytics);
                    }, 100);
                } catch (error) {
                    console.error('Error fetching session:', error);
                }
            };

            const updateCharts = (data) => {
                // Word Count Chart
                if (chartRefs.wordCount.current) {
                    const ctx = chartRefs.wordCount.current.getContext('2d');
                    if (chartInstances.current.wordCount) {
                        chartInstances.current.wordCount.destroy();
                    }
                    chartInstances.current.wordCount = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: data.turns.map(t => `Turn ${t}`),
                            datasets: [{
                                label: 'Word Count',
                                data: data.word_counts,
                                borderColor: '#667eea',
                                backgroundColor: 'rgba(102, 126, 234, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0.4,
                                pointRadius: 6,
                                pointHoverRadius: 8
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                title: { display: false }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    grid: { color: 'rgba(0,0,0,0.05)' }
                                },
                                x: {
                                    grid: { display: false }
                                }
                            }
                        }
                    });
                }

                // Sentiment Chart
                if (chartRefs.sentiment.current) {
                    const ctx = chartRefs.sentiment.current.getContext('2d');
                    if (chartInstances.current.sentiment) {
                        chartInstances.current.sentiment.destroy();
                    }
                    chartInstances.current.sentiment = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: data.turns.map(t => `Turn ${t}`),
                            datasets: [{
                                label: 'Sentiment Score',
                                data: data.sentiment_scores,
                                backgroundColor: data.sentiment_scores.map(s =>
                                    s > 0 ? 'rgba(76, 175, 80, 0.7)' : 'rgba(244, 67, 54, 0.7)'
                                ),
                                borderColor: data.sentiment_scores.map(s =>
                                    s > 0 ? '#4caf50' : '#f44336'
                                ),
                                borderWidth: 2
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false }
                            },
                            scales: {
                                y: {
                                    min: -1,
                                    max: 1,
                                    grid: { color: 'rgba(0,0,0,0.05)' }
                                },
                                x: {
                                    grid: { display: false }
                                }
                            }
                        }
                    });
                }

                // Confidence Chart
                if (chartRefs.confidence.current) {
                    const ctx = chartRefs.confidence.current.getContext('2d');
                    if (chartInstances.current.confidence) {
                        chartInstances.current.confidence.destroy();
                    }
                    chartInstances.current.confidence = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: data.turns.map(t => `Turn ${t}`),
                            datasets: [{
                                label: 'Confidence Level',
                                data: data.confidence_scores,
                                borderColor: '#ff9800',
                                backgroundColor: 'rgba(255, 152, 0, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0.4,
                                pointRadius: 6,
                                pointHoverRadius: 8
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false }
                            },
                            scales: {
                                y: {
                                    min: 0,
                                    max: 100,
                                    grid: { color: 'rgba(0,0,0,0.05)' }
                                },
                                x: {
                                    grid: { display: false }
                                }
                            }
                        }
                    });
                }
            };

            const updateSimilarityHeatmap = (matrix) => {
                if (chartRefs.similarityHeatmap.current && matrix.length > 0) {
                    const ctx = chartRefs.similarityHeatmap.current.getContext('2d');
                    if (chartInstances.current.similarityHeatmap) {
                        chartInstances.current.similarityHeatmap.destroy();
                    }

                    // Convert matrix to Chart.js matrix format
                    const data = [];
                    for (let y = 0; y < matrix.length; y++) {
                        for (let x = 0; x < matrix[y].length; x++) {
                            data.push({x, y, v: matrix[y][x]});
                        }
                    }

                    chartInstances.current.similarityHeatmap = new Chart(ctx, {
                        type: 'matrix',
                        data: {
                            datasets: [{
                                label: 'Cosine Similarity',
                                data: data,
                                backgroundColor: (ctx) => {
                                    const value = ctx.parsed.v;
                                    const alpha = Math.pow((value - 0.3) / 0.7, 0.5); // Non-linear scaling
                                    if (value > 0.95) return `rgba(0, 100, 0, ${alpha})`;
                                    if (value > 0.85) return `rgba(100, 180, 0, ${alpha})`;
                                    if (value > 0.7) return `rgba(255, 200, 0, ${alpha})`;
                                    if (value > 0.4) return `rgba(255, 120, 0, ${alpha})`;
                                    return `rgba(200, 0, 0, ${alpha})`;
                                },
                                borderWidth: 1,
                                borderColor: 'rgba(255, 255, 255, 0.3)',
                                width: ({chart}) => (chart.chartArea || {}).width / matrix.length - 1,
                                height: ({chart}) => (chart.chartArea || {}).height / matrix.length - 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                tooltip: {
                                    callbacks: {
                                        title: () => '',
                                        label: (ctx) => {
                                            const value = ctx.parsed.v;
                                            return `Turn ${ctx.parsed.y} → Turn ${ctx.parsed.x}: ${value.toFixed(3)}`;
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    type: 'category',
                                    labels: Array.from({length: matrix.length}, (_, i) => `T${i}`),
                                    offset: true,
                                    ticks: {
                                        display: true
                                    },
                                    grid: {
                                        display: false
                                    }
                                },
                                y: {
                                    type: 'category',
                                    labels: Array.from({length: matrix.length}, (_, i) => `T${i}`),
                                    offset: true,
                                    ticks: {
                                        display: true
                                    },
                                    grid: {
                                        display: false
                                    }
                                }
                            }
                        }
                    });
                }
            };

            const updateVectorMovement = (projection) => {
                if (chartRefs.vectorMovement.current && projection.coordinates) {
                    const ctx = chartRefs.vectorMovement.current.getContext('2d');
                    if (chartInstances.current.vectorMovement) {
                        chartInstances.current.vectorMovement.destroy();
                    }

                    const coords = projection.coordinates;

                    chartInstances.current.vectorMovement = new Chart(ctx, {
                        type: 'scatter',
                        data: {
                            datasets: [{
                                label: 'Response Evolution',
                                data: coords.map((c, i) => ({x: c[0], y: c[1], turn: i})),
                                backgroundColor: coords.map((_, i) =>
                                    `rgba(102, 126, 234, ${0.3 + (i / coords.length) * 0.7})`
                                ),
                                borderColor: coords.map((_, i) =>
                                    `rgba(102, 126, 234, ${0.5 + (i / coords.length) * 0.5})`
                                ),
                                borderWidth: 2,
                                pointRadius: 8,
                                pointHoverRadius: 12
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                tooltip: {
                                    callbacks: {
                                        label: (ctx) => `Turn ${ctx.raw.turn}`
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    grid: { color: 'rgba(0,0,0,0.05)' }
                                },
                                y: {
                                    grid: { color: 'rgba(0,0,0,0.05)' }
                                }
                            }
                        }
                    });

                    // Draw arrows between points
                    const chartArea = chartInstances.current.vectorMovement.chartArea;
                    const xScale = chartInstances.current.vectorMovement.scales.x;
                    const yScale = chartInstances.current.vectorMovement.scales.y;

                    ctx.save();
                    ctx.strokeStyle = 'rgba(102, 126, 234, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);

                    for (let i = 0; i < coords.length - 1; i++) {
                        const x1 = xScale.getPixelForValue(coords[i][0]);
                        const y1 = yScale.getPixelForValue(coords[i][1]);
                        const x2 = xScale.getPixelForValue(coords[i+1][0]);
                        const y2 = yScale.getPixelForValue(coords[i+1][1]);

                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();

                        // Draw arrowhead
                        const angle = Math.atan2(y2 - y1, x2 - x1);
                        const headLength = 10;
                        ctx.beginPath();
                        ctx.moveTo(x2, y2);
                        ctx.lineTo(
                            x2 - headLength * Math.cos(angle - Math.PI / 6),
                            y2 - headLength * Math.sin(angle - Math.PI / 6)
                        );
                        ctx.moveTo(x2, y2);
                        ctx.lineTo(
                            x2 - headLength * Math.cos(angle + Math.PI / 6),
                            y2 - headLength * Math.sin(angle + Math.PI / 6)
                        );
                        ctx.stroke();
                    }
                    ctx.restore();
                }
            };

            const updateSentenceComparison = (comparison) => {
                if (chartRefs.sentenceComparison.current && comparison.similarity_matrix) {
                    const ctx = chartRefs.sentenceComparison.current.getContext('2d');
                    if (chartInstances.current.sentenceComparison) {
                        chartInstances.current.sentenceComparison.destroy();
                    }

                    const matrix = comparison.similarity_matrix;
                    const data = [];
                    for (let y = 0; y < matrix.length; y++) {
                        for (let x = 0; x < matrix[y].length; x++) {
                            data.push({x, y, v: matrix[y][x]});
                        }
                    }

                    chartInstances.current.sentenceComparison = new Chart(ctx, {
                        type: 'matrix',
                        data: {
                            datasets: [{
                                label: 'Sentence Similarity',
                                data: data,
                                backgroundColor: (ctx) => {
                                    const value = ctx.parsed.v;
                                    const alpha = Math.pow((value - 0.2) / 0.8, 0.5);
                                    if (value > 0.8) return `rgba(0, 120, 0, ${alpha})`;
                                    if (value > 0.6) return `rgba(100, 200, 0, ${alpha})`;
                                    if (value > 0.4) return `rgba(255, 200, 0, ${alpha})`;
                                    return `rgba(200, 100, 100, ${alpha})`;
                                },
                                borderWidth: 1,
                                borderColor: 'rgba(255, 255, 255, 0.3)',
                                width: ({chart}) => (chart.chartArea || {}).width / matrix[0].length - 1,
                                height: ({chart}) => (chart.chartArea || {}).height / matrix.length - 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                tooltip: {
                                    callbacks: {
                                        title: () => '',
                                        label: (ctx) => {
                                            const value = ctx.parsed.v;
                                            const prevSent = comparison.previous_sentences[ctx.parsed.y] || '';
                                            const currSent = comparison.current_sentences[ctx.parsed.x] || '';
                                            return [
                                                `Similarity: ${value.toFixed(3)}`,
                                                `Previous: "${prevSent.substring(0, 50)}..."`,
                                                `Current: "${currSent.substring(0, 50)}..."`
                                            ];
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    type: 'category',
                                    labels: Array.from({length: matrix[0].length}, (_, i) => `New ${i+1}`),
                                    offset: true,
                                    ticks: { display: true },
                                    grid: { display: false }
                                },
                                y: {
                                    type: 'category',
                                    labels: Array.from({length: matrix.length}, (_, i) => `Prev ${i+1}`),
                                    offset: true,
                                    ticks: { display: true },
                                    grid: { display: false }
                                }
                            }
                        }
                    });
                }
            };

            const getSimilarityBadgeClass = (cosine) => {
                if (cosine > 0.95) return 'badge-tiny';
                if (cosine > 0.85) return 'badge-small';
                if (cosine > 0.70) return 'badge-moderate';
                if (cosine > 0.40) return 'badge-big';
                return 'badge-major';
            };

            return (
                <div className="min-h-screen py-8 px-4">
                    <div className="max-w-7xl mx-auto">
                        {/* Header */}
                        <div className="gradient-bg rounded-2xl p-8 mb-8 text-white shadow-2xl">
                            <h1 className="text-4xl font-bold mb-3">🧠 LLM Learning Visualizer</h1>
                            <p className="text-xl opacity-90">
                                See how AI changes its mind when you correct it - with beautiful semantic visualizations!
                            </p>
                            <p className="text-sm opacity-75 mt-2">
                                Understand semantic similarity, vector embeddings, and how LLMs learn from feedback
                            </p>
                        </div>

                        {/* Quick Start Guide */}
                        {!sessionId && (
                            <CollapsibleSection
                                title="📖 How to Use This Tool"
                                icon="🚀"
                                defaultOpen={true}
                                colorClass="bg-blue-50"
                            >
                                <div className="space-y-4">
                                    <div className="flex items-start gap-3">
                                        <span className="text-2xl">1️⃣</span>
                                        <div>
                                            <h4 className="font-semibold text-lg">Ask a Question</h4>
                                            <p className="text-gray-600">Start with any question. Try: "When did the Mexican-American War end?"</p>
                                        </div>
                                    </div>
                                    <div className="flex items-start gap-3">
                                        <span className="text-2xl">2️⃣</span>
                                        <div>
                                            <h4 className="font-semibold text-lg">Correct the AI</h4>
                                            <p className="text-gray-600">If the answer isn't perfect, provide corrections to see how the AI adapts</p>
                                        </div>
                                    </div>
                                    <div className="flex items-start gap-3">
                                        <span className="text-2xl">3️⃣</span>
                                        <div>
                                            <h4 className="font-semibold text-lg">Explore Visualizations</h4>
                                            <p className="text-gray-600">Watch the semantic heatmaps and vector movements show HOW the meaning changed</p>
                                        </div>
                                    </div>
                                </div>
                            </CollapsibleSection>
                        )}

                        {/* Input Section */}
                        {!sessionId ? (
                            <div className="bg-white rounded-xl p-8 shadow-lg mb-8">
                                <h2 className="text-2xl font-bold mb-4 text-gray-800">Ask Your Question</h2>
                                <textarea
                                    className="w-full p-4 border-2 border-gray-300 rounded-lg focus:border-purple-500 focus:outline-none resize-none text-lg"
                                    rows="4"
                                    value={question}
                                    onChange={(e) => setQuestion(e.target.value)}
                                    placeholder="Try: When did the Mexican-American War end?"
                                    disabled={loading}
                                />
                                <button
                                    onClick={startSession}
                                    disabled={loading || !question.trim()}
                                    className="mt-4 gradient-bg text-white px-8 py-3 rounded-lg font-semibold text-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed transition-all transform hover:scale-105"
                                >
                                    {loading ? 'Thinking...' : '🚀 Start Learning Session'}
                                </button>
                            </div>
                        ) : (
                            <div className="bg-white rounded-xl p-8 shadow-lg mb-8">
                                <h2 className="text-2xl font-bold mb-4 text-gray-800">Provide Correction</h2>
                                <textarea
                                    className="w-full p-4 border-2 border-gray-300 rounded-lg focus:border-purple-500 focus:outline-none resize-none text-lg"
                                    rows="3"
                                    value={currentCorrection}
                                    onChange={(e) => setCurrentCorrection(e.target.value)}
                                    placeholder="Tell the AI what was wrong or what to add..."
                                    disabled={loading}
                                />
                                <div className="flex gap-4 mt-4">
                                    <button
                                        onClick={submitCorrection}
                                        disabled={loading || !currentCorrection.trim()}
                                        className="gradient-bg text-white px-8 py-3 rounded-lg font-semibold text-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed transition-all transform hover:scale-105"
                                    >
                                        {loading ? 'Processing...' : '✏️ Submit Correction'}
                                    </button>
                                    <button
                                        onClick={() => {
                                            setSessionId(null);
                                            setResponses([]);
                                            setSemanticData(null);
                                            setAnalytics(null);
                                            setQuestion('');
                                        }}
                                        className="bg-gray-200 text-gray-800 px-8 py-3 rounded-lg font-semibold text-lg hover:bg-gray-300 transition-all"
                                    >
                                        🔄 New Session
                                    </button>
                                </div>
                            </div>
                        )}

                        {/* Responses */}
                        {responses.length > 0 && (
                            <div className="space-y-6 mb-8">
                                <h2 className="text-3xl font-bold text-gray-800">💬 Conversation</h2>
                                {responses.map((resp, idx) => (
                                    <div key={idx} className="response-box bg-white rounded-xl p-6 shadow-lg">
                                        <div className="flex items-center gap-3 mb-4">
                                            <span className="text-3xl">{resp.type === 'initial' ? '🤖' : '✨'}</span>
                                            <div>
                                                <h3 className="text-xl font-bold text-gray-800">
                                                    Turn {resp.turn}: {resp.type === 'initial' ? 'Initial Answer' : 'Corrected Answer'}
                                                </h3>
                                                <p className="text-sm text-gray-500">
                                                    {resp.analysis.word_count} words • {resp.analysis.sentence_count} sentences
                                                </p>
                                            </div>
                                        </div>
                                        <p className="text-lg text-gray-700 leading-relaxed">
                                            {resp.response}
                                        </p>
                                    </div>
                                ))}
                            </div>
                        )}

                        {/* Basic Analytics */}
                        {analytics && (
                            <CollapsibleSection
                                title="📊 Basic Text Analytics"
                                icon="📈"
                                defaultOpen={true}
                                colorClass="bg-green-50"
                            >
                                <ExplanationBox title="What This Shows">
                                    These charts track simple text properties: word count (answer length),
                                    sentiment (positive/negative tone), and confidence level (certainty in the answer).
                                </ExplanationBox>

                                <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                                    <div className="chart-container">
                                        <h3 className="font-semibold text-gray-700 mb-3">Response Length</h3>
                                        <div style={{height: '200px'}}>
                                            <canvas ref={chartRefs.wordCount}></canvas>
                                        </div>
                                    </div>
                                    <div className="chart-container">
                                        <h3 className="font-semibold text-gray-700 mb-3">Sentiment Analysis</h3>
                                        <div style={{height: '200px'}}>
                                            <canvas ref={chartRefs.sentiment}></canvas>
                                        </div>
                                    </div>
                                    <div className="chart-container">
                                        <h3 className="font-semibold text-gray-700 mb-3">Confidence Level</h3>
                                        <div style={{height: '200px'}}>
                                            <canvas ref={chartRefs.confidence}></canvas>
                                        </div>
                                    </div>
                                </div>
                            </CollapsibleSection>
                        )}

                        {/* Semantic Analysis */}
                        {semanticData && (
                            <>
                                {/* Theory Section */}
                                <CollapsibleSection
                                    title="📚 Understanding Semantic Similarity"
                                    icon="🎓"
                                    defaultOpen={false}
                                    colorClass="bg-cyan-50"
                                >
                                    <TheoryBox title="What is Semantic Similarity?">
                                        <p className="mb-3">
                                            <strong>Semantic similarity</strong> measures how similar two pieces of text are <em>in meaning</em>,
                                            not just in words. Two sentences can use completely different words but mean the same thing:
                                        </p>
                                        <div className="bg-white p-4 rounded-lg border-2 border-cyan-200 mb-3">
                                            <p className="font-mono text-sm mb-2">"The capital of France is Paris."</p>
                                            <p className="font-mono text-sm">"Paris is the capital city of France."</p>
                                            <p className="text-xs text-cyan-700 mt-2">→ High semantic similarity (~0.95) despite different word order!</p>
                                        </div>
                                    </TheoryBox>

                                    <TheoryBox title="How Do We Measure Meaning?">
                                        <p className="mb-3">
                                            We convert text into <strong>embeddings</strong> - high-dimensional vectors (lists of numbers)
                                            that capture the semantic meaning. Similar meanings produce similar vectors.
                                        </p>
                                        <div className="bg-white p-4 rounded-lg border-2 border-cyan-200">
                                            <p className="font-semibold mb-2">The Process:</p>
                                            <ol className="list-decimal list-inside space-y-1 text-sm">
                                                <li>Text → Neural Network → 384-dimensional vector</li>
                                                <li>Each dimension captures different aspects of meaning</li>
                                                <li>Compare vectors using <strong>cosine similarity</strong></li>
                                                <li>Similarity = 1.0 (identical) to 0.0 (completely different)</li>
                                            </ol>
                                        </div>
                                    </TheoryBox>
                                </CollapsibleSection>

                                {/* Similarity Heatmap */}
                                <CollapsibleSection
                                    title="🔥 Semantic Similarity Heatmap"
                                    icon="📊"
                                    defaultOpen={true}
                                    colorClass="bg-purple-50"
                                >
                                    <ExplanationBox title="What This Shows">
                                        This heatmap compares <em>every</em> answer to <em>every other</em> answer using cosine similarity.
                                        Green cells = very similar meanings, Red cells = very different meanings.
                                        The diagonal is always green (each answer compared to itself = 1.0).
                                    </ExplanationBox>

                                    <CalculationBox title="Cosine Similarity Formula">
                                        <pre className="text-xs">
{`cosine_similarity(A, B) = (A · B) / (||A|| × ||B||)

Where:
• A · B = dot product of vectors A and B
• ||A|| = magnitude (length) of vector A
• Result: 1.0 = identical, 0.0 = orthogonal, -1.0 = opposite

Example:
A = [0.8, 0.6], B = [0.9, 0.5]
A · B = 0.8×0.9 + 0.6×0.5 = 1.02
||A|| = √(0.8² + 0.6²) = 1.0
||B|| = √(0.9² + 0.5²) = 1.03
cosine_similarity = 1.02 / (1.0 × 1.03) = 0.990`}
                                        </pre>
                                    </CalculationBox>

                                    <div className="chart-container">
                                        <div style={{height: '400px'}}>
                                            <canvas ref={chartRefs.similarityHeatmap}></canvas>
                                        </div>
                                    </div>

                                    {/* Change Summary */}
                                    {semanticData.changes && semanticData.changes.length > 0 && (
                                        <div className="mt-6 space-y-4">
                                            <h4 className="font-bold text-lg text-gray-800">📊 Turn-by-Turn Changes</h4>
                                            {semanticData.changes.map((change, idx) => (
                                                <div key={idx} className="bg-gradient-to-r from-purple-50 to-pink-50 p-5 rounded-lg border-2 border-purple-200">
                                                    <div className="flex items-center justify-between mb-3">
                                                        <h5 className="font-semibold text-lg">
                                                            Turn {change.from_turn} → Turn {change.to_turn}
                                                        </h5>
                                                        <span className={`semantic-badge ${getSimilarityBadgeClass(change.cosine_similarity)}`}>
                                                            {change.explanation.split(':')[0]}
                                                        </span>
                                                    </div>
                                                    <p className="text-gray-700 mb-3 italic">
                                                        {change.explanation}
                                                    </p>
                                                    <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
                                                        <div className="bg-white p-3 rounded">
                                                            <p className="text-gray-500 text-xs">Cosine Similarity</p>
                                                            <p className="font-bold text-lg">{change.cosine_similarity.toFixed(3)}</p>
                                                        </div>
                                                        <div className="bg-white p-3 rounded">
                                                            <p className="text-gray-500 text-xs">Angle (degrees)</p>
                                                            <p className="font-bold text-lg">{change.angle_degrees.toFixed(1)}°</p>
                                                        </div>
                                                        <div className="bg-white p-3 rounded">
                                                            <p className="text-gray-500 text-xs">Word Overlap</p>
                                                            <p className="font-bold text-lg">{(change.jaccard_similarity * 100).toFixed(0)}%</p>
                                                        </div>
                                                        <div className="bg-white p-3 rounded">
                                                            <p className="text-gray-500 text-xs">Length Change</p>
                                                            <p className="font-bold text-lg">{change.length_change_pct > 0 ? '+' : ''}{change.length_change_pct.toFixed(0)}%</p>
                                                        </div>
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                </CollapsibleSection>

                                {/* Vector Movement */}
                                {semanticData.projection_2d && (
                                    <CollapsibleSection
                                        title="🎯 Vector Movement in Semantic Space"
                                        icon="📍"
                                        defaultOpen={true}
                                        colorClass="bg-blue-50"
                                    >
                                        <ExplanationBox title="What This Shows">
                                            This plot shows how the AI's answer "moves" in meaning space. Each point represents one answer,
                                            projected from 384 dimensions down to 2D for visualization. Arrows show the path of semantic change.
                                            Darker points = later turns (more corrections incorporated).
                                        </ExplanationBox>

                                        <CalculationBox title="Dimensionality Reduction">
                                            <pre className="text-xs">
{`We use ${semanticData.projection_2d.method.toUpperCase()} (${
    semanticData.projection_2d.method === 'umap' ? 'Uniform Manifold Approximation and Projection' : 'Principal Component Analysis'
})

Purpose: Reduce 384-dimensional embeddings → 2D for visualization
Method preserves: ${semanticData.projection_2d.method === 'umap' ? 'local structure & clusters' : 'maximum variance'}
${semanticData.projection_2d.explained_variance ?
`Explained variance: ${(semanticData.projection_2d.explained_variance[0] * 100).toFixed(1)}% (PC1), ${(semanticData.projection_2d.explained_variance[1] * 100).toFixed(1)}% (PC2)` : ''}`}
                                            </pre>
                                        </CalculationBox>

                                        <div className="chart-container">
                                            <div style={{height: '500px'}}>
                                                <canvas ref={chartRefs.vectorMovement}></canvas>
                                            </div>
                                        </div>

                                        <div className="mt-4 bg-blue-50 p-4 rounded-lg">
                                            <p className="text-sm text-blue-900">
                                                <strong>💡 Interpretation:</strong> Large jumps between points indicate significant semantic changes.
                                                Small movements suggest minor refinements. The path traces the AI's "journey" as it incorporates
                                                your corrections.
                                            </p>
                                        </div>
                                    </CollapsibleSection>
                                )}

                                {/* Sentence-Level Comparison */}
                                {semanticData.sentence_comparison && (
                                    <CollapsibleSection
                                        title="📝 Sentence-Level Comparison"
                                        icon="🔍"
                                        defaultOpen={true}
                                        colorClass="bg-orange-50"
                                    >
                                        <ExplanationBox title="What This Shows">
                                            This heatmap compares individual sentences between the previous answer and current answer.
                                            Each cell shows: "How similar is sentence X from the previous answer to sentence Y from the current answer?"
                                            This reveals which ideas were kept, modified, or replaced entirely.
                                        </ExplanationBox>

                                        <div className="chart-container">
                                            <div style={{height: '400px'}}>
                                                <canvas ref={chartRefs.sentenceComparison}></canvas>
                                            </div>
                                        </div>

                                        <div className="mt-6 grid grid-cols-1 md:grid-cols-2 gap-6">
                                            <div>
                                                <h4 className="font-semibold text-gray-800 mb-3">Previous Answer Sentences</h4>
                                                <div className="space-y-2">
                                                    {semanticData.sentence_comparison.previous_sentences.map((sent, idx) => (
                                                        <div key={idx} className="bg-red-50 p-3 rounded border-l-4 border-red-400">
                                                            <p className="text-xs text-gray-500 mb-1">Prev {idx + 1}</p>
                                                            <p className="text-sm text-gray-800">{sent}</p>
                                                        </div>
                                                    ))}
                                                </div>
                                            </div>
                                            <div>
                                                <h4 className="font-semibold text-gray-800 mb-3">Current Answer Sentences</h4>
                                                <div className="space-y-2">
                                                    {semanticData.sentence_comparison.current_sentences.map((sent, idx) => (
                                                        <div key={idx} className="bg-green-50 p-3 rounded border-l-4 border-green-400">
                                                            <p className="text-xs text-gray-500 mb-1">New {idx + 1}</p>
                                                            <p className="text-sm text-gray-800">{sent}</p>
                                                        </div>
                                                    ))}
                                                </div>
                                            </div>
                                        </div>

                                        <div className="mt-4 bg-orange-50 p-4 rounded-lg">
                                            <p className="text-sm text-orange-900">
                                                <strong>💡 Reading the Heatmap:</strong> High similarity (green) on the diagonal means sentences
                                                kept their core meaning. High similarity off-diagonal means sentence reordering. Low similarity (red)
                                                across a row means that sentence was removed or completely rewritten.
                                            </p>
                                        </div>
                                    </CollapsibleSection>
                                )}
                            </>
                        )}

                        {/* Additional Metrics */}
                        {semanticData && semanticData.changes && semanticData.changes.length > 0 && (
                            <CollapsibleSection
                                title="📐 Additional Similarity Metrics"
                                icon="🔢"
                                defaultOpen={false}
                                colorClass="bg-yellow-50"
                            >
                                <TheoryBox title="Multiple Ways to Measure Similarity">
                                    <p className="mb-3">
                                        Different metrics capture different aspects of similarity:
                                    </p>
                                    <div className="space-y-3">
                                        <div className="bg-white p-3 rounded border-l-4 border-blue-400">
                                            <p className="font-semibold">Cosine Similarity (semantic)</p>
                                            <p className="text-sm">Measures meaning similarity using embeddings. Range: 0.0 to 1.0</p>
                                        </div>
                                        <div className="bg-white p-3 rounded border-l-4 border-green-400">
                                            <p className="font-semibold">Jaccard Similarity (word overlap)</p>
                                            <p className="text-sm">Percentage of words shared between texts. Formula: |A ∩ B| / |A ∪ B|</p>
                                        </div>
                                        <div className="bg-white p-3 rounded border-l-4 border-purple-400">
                                            <p className="font-semibold">Vector Angle (geometric)</p>
                                            <p className="text-sm">Angle between embedding vectors. 0° = identical, 90° = orthogonal, 180° = opposite</p>
                                        </div>
                                        <div className="bg-white p-3 rounded border-l-4 border-orange-400">
                                            <p className="font-semibold">Length Change (structural)</p>
                                            <p className="text-sm">Percentage change in response length (character count)</p>
                                        </div>
                                    </div>
                                </TheoryBox>

                                <CalculationBox title="Example Calculations">
                                    <pre className="text-xs">
{`Text A: "Paris is the capital of France"
Text B: "The French capital city is Paris"

1. Cosine Similarity (after embedding):
   embedding_A = [0.45, 0.82, 0.15, ... 384 dimensions]
   embedding_B = [0.48, 0.79, 0.18, ... 384 dimensions]
   cosine_sim = 0.967 (very similar!)

2. Jaccard Similarity (word overlap):
   words_A = {paris, capital, france}
   words_B = {french, capital, city, paris}
   intersection = {paris, capital} = 2 words
   union = {paris, capital, france, french, city} = 5 words
   jaccard = 2/5 = 0.400 (40% overlap)

3. Vector Angle:
   angle = arccos(0.967) × 180/π = 14.8°

4. Length Change:
   len_A = 31 chars, len_B = 34 chars
   change = ((34-31)/31) × 100 = +9.7%`}
                                    </pre>
                                </CalculationBox>
                            </CollapsibleSection>
                        )}

                        {/* Footer with link to explainers */}
                        <div className="mt-12 gradient-bg-green rounded-xl p-8 text-white text-center">
                            <h3 className="text-2xl font-bold mb-3">🎓 Want to Learn More?</h3>
                            <p className="text-lg mb-4">
                                Explore interactive demos that explain attention mechanisms, temperature effects, and more!
                            </p>
                            <a
                                href="explainers.html"
                                className="inline-block bg-white text-green-700 px-8 py-3 rounded-lg font-bold text-lg hover:bg-gray-100 transition-all transform hover:scale-105"
                            >
                                🚀 Open Interactive Explainers
                            </a>
                        </div>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
